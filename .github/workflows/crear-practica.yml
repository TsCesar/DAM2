name: Crear práctica desde Issue

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Número del issue a procesar (manual)"
        required: false
        type: string

permissions:
  contents: write
  issues: write

jobs:
  crear:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' &&
       ((github.event.action == 'opened' && contains(github.event.issue.body, '### Autor/a')) ||
        (github.event.action == 'labeled' && github.event.label.name == 'nueva-practica')))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Lee issue y expone outputs
        id: datos
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            let issue, num;

            async function pickIssue() {
              const input = core.getInput('issue_number');
              if (input) {
                const n = parseInt(input, 10);
                if (!Number.isFinite(n)) core.setFailed(`issue_number inválido: ${input}`);
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: n });
                return { issue: data, num: n };
              }
              const list = await github.paginate(github.rest.issues.listForRepo, {
                owner, repo, state: 'open', labels: 'nueva-practica', per_page: 1
              });
              if (!list.length) {
                core.setFailed('No se proporcionó issue_number y no hay issues abiertos con la etiqueta "nueva-practica".');
                return {};
              }
              return { issue: list[0], num: list[0].number };
            }

            if (context.eventName === 'workflow_dispatch') {
              ({ issue, num } = await pickIssue());
              if (!issue) return;
            } else {
              issue = context.payload.issue;
              num = issue.number;
            }

            const body = issue.body || '';
            const escRe = s => s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
            const campo = h => {
              const re = new RegExp(`(?:^|\\n)\\s*###\\s*${escRe(h)}\\s*\\n([\\s\\S]*?)(?=\\n###\\s|$)`,'i');
              const m = body.match(re);
              return m ? m[1].trim() : '';
            };

            const autor     = campo('Autor/a');
            const moduloRaw = (campo('Módulo') || '').toLowerCase();
            let practica    = campo('Nombre de la práctica (slug)') || campo('Nombre de la práctica');
            let archivo     = campo('Archivo principal (con extensión)') || 'main.txt';
            const contenido = campo('Contenido inicial del archivo principal');

            const slugify = s => (s||'').toLowerCase().replace(/[^a-z0-9-]+/g,'-').replace(/^-+|-+$/g,'');
            const modulo = moduloRaw;
            practica = slugify(practica || '');
            archivo  = (archivo||'main.txt').replace(/^[\\/]+/,'').replace(/\s+/g,'-');
            if (!/\./.test(archivo)) archivo += '.txt';

            const valid = [
              '01-acceso-datos',
              '02-computacion-descentralizada-blockchain',
              '03-desarrollo-interfaces',
              '04-programacion-servicios-procesos',
              '05-programacion-multimedia-moviles',
              '06-sistemas-gestion-empresarial'
            ];
            if (!valid.includes(modulo)) {
              core.setFailed(`Módulo no válido: ${modulo}`);
              return;
            }

            // Guarda contenido temporal
            const fs = require('fs');
            fs.writeFileSync('contenido_tmp.txt', contenido || '', { encoding: 'utf8' });

            // Outputs
            core.setOutput('issue_number', String(num));
            core.setOutput('autor', autor || '');
            core.setOutput('mod', modulo);
            core.setOutput('prac', practica);
            core.setOutput('file', archivo);

      # ===== NUEVO: bloquea slugs duplicados =====
      - name: Verifica que el slug no exista ya
        shell: bash
        env:
          MOD:  ${{ steps.datos.outputs.mod }}
          PRAC: ${{ steps.datos.outputs.prac }}
        run: |
          set -e
          root="$MOD/practicas/$PRAC"
          if [ -d "$root" ]; then
            echo "EXISTS=1" >> "$GITHUB_ENV"
            echo "::error title=Slug duplicado::${root} ya existe. Elige otro slug para la práctica."
            exit 1
          fi

      - name: Crea estructura y README mínimo (autor + código)
        shell: bash
        env:
          MOD:   ${{ steps.datos.outputs.mod }}
          PRAC:  ${{ steps.datos.outputs.prac }}
          FILE:  ${{ steps.datos.outputs.file }}
          AUTOR: ${{ steps.datos.outputs.autor }}
        run: |
          set -e
          root="$MOD/practicas/$PRAC"
          mkdir -p "$root"
          if [ -s "contenido_tmp.txt" ]; then
            cp "contenido_tmp.txt" "$root/$FILE"
          else
            printf "// Pega aquí tu código para %s\n" "$FILE" > "$root/$FILE"
          fi
          ext="${FILE##*.}"
          case "$ext" in
            java) lang=java ;; kt) lang=kotlin ;; py) lang=python ;;
            js) lang=javascript ;; ts) lang=typescript ;;
            html) lang=html ;; css) lang=css ;; xml) lang=xml ;;
            sql) lang=sql ;; md) lang=markdown ;; *) lang="" ;;
          esac
          {
            printf '**Autor/a:** %s\n\n' "${AUTOR:-Desconocido}"
            if [ -n "$lang" ]; then printf '```%s\n' "$lang"; else printf '```\n'; fi
            cat "$root/$FILE"
            printf '\n```\n'
          } > "$root/README.md"

      - name: Actualiza índice, listas y tabla
        shell: bash
        run: |
          chmod +x scripts/*.sh || true
          scripts/actualiza_indice.sh || true
          scripts/actualiza_listas_modulos.sh || true
          scripts/actualiza_tabla_practicas.sh || true

      - name: Commit y push
        shell: bash
        env:
          MOD:  ${{ steps.datos.outputs.mod }}
          PRAC: ${{ steps.datos.outputs.prac }}
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add README.md docs/INDICE.md 0*/README.md "$MOD/practicas/$PRAC" || true
          git commit -m "feat(${MOD}): añade práctica ${PRAC} + docs auto [skip ci]" || echo "Nada que commitear"
          git push

      # ===== NUEVO: comenta si hubo slug duplicado =====
      - name: Notifica duplicado en el issue (si aplica)
        if: ${{ always() && env.EXISTS == '1' && github.event_name != 'workflow_dispatch' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const num  = parseInt('${{ steps.datos.outputs.issue_number }}', 10);
            const prac = '${{ steps.datos.outputs.prac }}';
            const mod  = '${{ steps.datos.outputs.mod }}';
            const msg  = `⚠️ El slug \`${prac}\` ya existe en \`${mod}/practicas/${prac}\`. Por favor elige otro.`;
            await github.rest.issues.createComment({ owner, repo, issue_number: num, body: msg });

      - name: Comenta y cierra el issue (si no es manual)
        if: ${{ github.event_name != 'workflow_dispatch' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const num   = parseInt('${{ steps.datos.outputs.issue_number }}', 10);
            const mod   = '${{ steps.datos.outputs.mod }}';
            const prac  = '${{ steps.datos.outputs.prac }}';
            const ref   = (context.ref || 'refs/heads/main').replace('refs/heads/','');
            const url   = `${context.payload.repository.html_url}/blob/${ref}/${mod}/practicas/${prac}/README.md`;
            const msg   = `✅ Práctica creada: [${prac}](${url})\n\nSe han actualizado el **README**, las listas de cada módulo y \`docs/INDICE.md\`.`;
            await github.rest.issues.createComment({ owner, repo, issue_number: num, body: msg });
            await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
